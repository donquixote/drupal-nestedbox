<?php

use Drupal\nestedbox_core\NestedBox;
use Drupal\nestedbox_core\NestedBoxController;
use Drupal\nestedbox_core\NestedBoxInlineEntityFormController;
use Drupal\nestedbox_core\NestedBoxType;
use Drupal\nestedbox_core\NestedBoxTypeController;
use Drupal\nestedbox_core\NestedBoxTypeUIController;

xautoload()->registerModulePsr4(__FILE__, 'psr4');

/**
 * Implements hook_permission()
 */
function nestedbox_core_permission() {
  return array(
    'administer nestedbox types' => array(
      'title' => t('Administer Nested Box entities'),
      'description' => t('Perform administration tasks for my module.'),
    ),
  );
}

/**
 * Implements hook_theme()
 *
 * @return array
 */
function nestedbox_core_theme() {
  return array(
    'nestedbox' => array(
      'render element' => 'elements',
      'template' => 'nestedbox',
      'path' => drupal_get_path('module', 'nestedbox_core') . '/theme',
    ),
  );
}

function template_preprocess_nestedbox(&$variables) {
  module_load_include('theme.inc', 'entity', 'theme/entity');
  template_preprocess_entity($variables);
  unset($variables['title']);
}

/**
 * Implements hook_entity_info().
 *
 * Inspired by entity_operations/example_entity, and typical_entity_example.
 */
function nestedbox_core_entity_info() {
  $info = array();

  $info['nestedbox'] = array(
    'label' => t('Nested Box'),
    'plural label' => t('Nested Boxes'),
    'base table' => 'nestedbox',
    'entity keys' => array(
      'id' => 'nestedbox_id',
      'bundle' => 'type',
      'label' => 'admin_title',
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'entity class' => NestedBox::getClassName(),
    'controller class' => NestedBoxController::getClassName(),
    'metadata controller class' => '',
    'fieldable' => TRUE,
    'uri callback' => 'entity_operations_entity_uri',
    'label callback' => 'entity_class_label',
    'module' => 'nestedbox_core',
    'access callback' => 'nestedbox_access',
    'admin ui' => array(
      'path' => 'admin/content/nestedbox',
      // We need our own controller for this, because we're using generic
      // entity form operations.
      'controller class' => 'EntityOperationsDefaultAdminUIController',
    ),
    // Entity Operations API
    'operations ui' => array(
      // The base path for your entities. This is the same as your entity's URI
      // but without the ID suffix. (In fact, you can set
      // entity_operations_entity_uri() as your URI callback, which will use the
      // value here).
      'path' => 'nestedbox',
    ),
  );

  if (module_exists('inline_entity_form')) {
    $info['nestedbox']['inline entity form'] = array(
      'controller' => NestedBoxInlineEntityFormController::getClassName(),
    );
  }

  $info['nestedbox_type'] = array(
    'label' => t('Nested Box type'),
    'entity class' => NestedBoxType::getClassName(),
    'controller class' => NestedBoxTypeController::getClassName(),
    'base table' => 'nestedbox_type',
    'fieldable' => FALSE,
    'bundle of' => 'nestedbox',
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'name' => 'type',
      'label' => 'label',
    ),
    'access callback' => 'nestedbox_type_access',
    'module' => 'nestedbox_core',
    // Enable the entity API's admin UI.
    'admin ui' => array(
      'path' => 'admin/structure/nestedbox-types',
      'file' => 'nestedbox_type.admin.inc',
      'controller class' => NestedBoxTypeUIController::getClassName(),
    ),
  );

  return $info;
}

/**
 * Implements hook_entity_info_alter().
 *
 * We are adding the info about the nestedbox types via a hook to avoid a
 * recursion issue, as loading the nestedbox types requires the entity info as
 * well.
 */
function nestedbox_core_entity_info_alter(&$entity_info) {
  foreach (nestedbox_get_types() as $type => $info) {
    $entity_info['nestedbox']['bundles'][$type] = array(
      'label' => $info->label,
      'admin' => array(
        'path' => 'admin/structure/nestedbox-types/manage/%nestedbox_type',
        'real path' => 'admin/structure/nestedbox-types/manage/' . $type,
        'bundle argument' => 4,
        'access arguments' => array('administer nestedbox types'),
      ),
    );
  }
}

/**
 * Gets an array of all nestedbox types, keyed by the type name.
 *
 * @return NestedBoxType[]
 *   An array of nestedbox types.
 */
function nestedbox_get_types() {
  // entity_load() will get the Entity controller for our nestedbox entity and
  // call the load function of that object - we are loading entities by name
  // here.
  return entity_load_multiple_by_name('nestedbox_type');
}

/**
 * Gets an nestedbox type.
 *
 * @param string $type_name
 *   If set, the type with the given name is returned.
 *
 * @return NestedBoxType|null
 *   The nested box type entity with the given name, or NULL if not found.
 */
function nestedbox_get_type($type_name) {
  // entity_load() will get the Entity controller for our nestedbox entity and
  // call the load function of that object - we are loading entities by name
  // here.
  $types = entity_load_multiple_by_name('nestedbox_type', array($type_name));
  if (!isset($types[$type_name])) {
    return NULL;
  }
  return $types[$type_name];
}

/**
 * Menu argument loader; Load a nestedbox type by string.
 *
 * @param $type_name
 *   The machine-readable name of a nestedbox type to load.
 *
 * @return NestedBoxType|false
 *   A nestedbox type array, or FALSE if $type does not exist.
 */
function nestedbox_type_load($type_name) {
  return nestedbox_get_type($type_name);
}

/**
 * Implements hook_entity_operation_info().
 */
function nestedbox_core_entity_operation_info() {
  $info = array();

  $info['nestedbox'] = array(
    'add' => array(
      'handler' => 'EntityOperationsOperationAddGeneric',
      'provision' => array(
        'menu' => TRUE,
      ),
    ),
    'view' => array(
      // Or try EntityOperationsOperationEntityViewOperations!
      'handler' => 'EntityOperationsOperationEntityView',
      'provision' => array(
        'menu' => array(
          'default' => TRUE,
        ),
        'views field' => TRUE,
      ),
    ),
    'edit' => array(
      'handler' => 'EntityOperationsOperationEditGeneric',
      'provision' => array(
        'menu' => TRUE,
        'views field' => TRUE,
      ),
    ),
    'devel/devel' => array(
      'handler' => 'EntityOperationsOperationDevel',
      'provision' => array(
        'menu' => array(
          'default secondary' => TRUE,
        ),
      ),
    ),
    'devel/token' => array(
      // Note this only shows if you have Entity Token module enabled.
      'handler' => 'EntityOperationsOperationToken',
      'provision' => array(
        'menu' => TRUE,
      ),
    ),
    'devel/metadata' => array(
      'handler' => 'EntityOperationsOperationMetadata',
      'provision' => array(
        'menu' => TRUE,
      ),
    ),
    'author' => array(
      'handler' => 'EntityOperationsOperationSetOwner',
      'provision' => array(
        'menu' => TRUE,
        //'entity view' => TRUE,
      ),
    ),
  );

  $info['_nestedbox_type'] = array(
    'add' => array(
      'handler' => 'EntityOperationsOperationAddGeneric',
      'provision' => array(
        'menu' => TRUE,
      ),
    ),
    'edit' => array(
      'handler' => 'EntityOperationsOperationEditGeneric',
      'provision' => array(
        'menu' => array(
          'default' => TRUE,
        ),
      ),
    ),
  );

  return $info;
}

/**
 * Implements hook_entity_property_info().
 *
 * This implementation is necessary for dealing with Entity Metadata Wrappers.
 * @see http://drupal.org/node/1021466
 */
function nestedbox_core_entity_property_info() {
  $info = array();
  $properties = &$info['nestedbox']['properties'];
  $properties['nestedbox_id'] = array(
    'type' => 'integer',
    'schema field' => 'nestedbox_id',
    'label' => t('The primary identifier.'),
    'setter callback' => 'entity_property_verbatim_set',
  );
  $properties['admin_title'] = array(
    'type' => 'text',
    'schema_field' => 'admin_title',
    'required' => FALSE,
    'label' => t('Administrative title'),
    'setter callback' => 'entity_property_verbatim_set',
  );
  $properties['type'] = array(
    'type' => 'text',
    'schema field' => 'type',
    'required' => TRUE,
    'label' => t('Nested Box type (bundle)'),
    'setter callback' => 'entity_property_verbatim_set',
  );
  return $info;
}

/**
 * Implements hook_menu().
 */
function nestedbox_core_menu() {
  $items = array();

  // URI for deleting entity bundles.
  $items['admin/structure/nestedbox/%nestedbox_type/delete'] = array(
    'title' => 'Delete nested box',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nestedbox_type_form_delete_confirm', 4),
    'access arguments' => array('administer nestedbox types'),
    'weight' => 1,
    'type' => MENU_NORMAL_ITEM,
    'file' => 'nestedbox_type.admin.inc',
  );

  return $items;
}

/**
 * Implements callback_entity_access().
 */
function nestedbox_access($op, $entity, $account, $entity_type) {
  // TODO: add access control here.
  return TRUE;
}

/**
 * Load multiple instances of nestedbox_type.
 * 
 * @param string $type_name
 *   Name of the entity type to load.
 * 
 * @return mixed
 *   Founded entity type, or false.
 */
function nestedbox_type_load_multiple($type_name = NULL) {
  $types = entity_load_multiple_by_name('nestedbox_type', isset($type_name) ? array($type_name) : FALSE);
  return isset($type_name) ? reset($types) : $types;
}

/**
 * Access callback for nestedbox_type.
 */
function nestedbox_type_access($op, $entity = NULL) {
  return user_access('administer nestedbox types');
}

/**
 * Implements hook_form_FORM_ID_alter()
 *
 * @param array $form
 */
function nestedbox_core_form_entity_operations_operation_form_nestedbox_edit_alter(&$form) {
  $form['admin_title']['#title'] = t('Administrative title');
}
